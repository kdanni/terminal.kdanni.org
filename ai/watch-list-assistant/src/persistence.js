const fs = require('node:fs');
const path = require('node:path');

const { resolveWatchListCandidates } = require('./assetResolver');

const DEFAULT_OUTPUT_DIR = path.resolve(process.cwd(), 'ai-output');
const CSV_HEADERS = [
  'symbol',
  'exchange',
  'active',
  'olhcv_ready',
  'economic_anchor',
  'sentiment_pulse',
  'resolution_method',
  'resolution_confidence',
  'resolution_notes'
];

function ensureDirectory(dirPath) {
  fs.mkdirSync(dirPath, { recursive: true });
}

function escapeCsv(value) {
  const str = value == null ? '' : String(value);
  if (/[",\n]/.test(str)) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

function formatResolutionNotes(resolution) {
  if (!resolution?.meta) {
    return '';
  }
  return Object.entries(resolution.meta)
    .map(([key, value]) => `${key}:${value}`)
    .join('|');
}

function toCsv(entries) {
  const lines = [CSV_HEADERS.join(',')];
  entries.forEach((entry) => {
    const row = [
      entry.symbol,
      entry.exchange ?? '',
      entry.active ? '1' : '0',
      entry.olhcv_ready ? '1' : '0',
      entry.economic_anchor || '',
      entry.sentiment_pulse || '',
      entry.resolution?.method || '',
      entry.resolution?.confidence || '',
      formatResolutionNotes(entry.resolution)
    ].map(escapeCsv);
    lines.push(row.join(','));
  });
  return lines.join('\n');
}

function escapeSql(value) {
  return String(value ?? '').replace(/'/g, "''");
}

function buildSqlScript(entries) {
  if (!entries.length) {
    return '-- No watch list entries generated by the AI fine-tuning phase.';
  }
  const values = entries
    .map((entry) => {
      const exchangeValue = entry.exchange == null ? '' : entry.exchange;
      return `    ('${escapeSql(entry.symbol)}', '${escapeSql(exchangeValue)}', ${entry.active ? 'TRUE' : 'FALSE'})`;
    })
    .join(',\n');
  return [
    'INSERT INTO asset_watch_list (symbol, exchange, active)',
    'VALUES',
    `${values}`,
    'ON CONFLICT ON CONSTRAINT asset_watch_list_symbol_exchange_idx DO UPDATE',
    'SET',
    '    active = EXCLUDED.active,',
    '    updated_at = NOW();'
  ].join('\n');
}

function normalizeEntries(resolvedEntries) {
  return resolvedEntries.map(({ candidate, symbol, exchange, resolution }) => ({
    symbol,
    exchange: exchange ?? '',
    active: true,
    olhcv_ready: Boolean(candidate.olhcv_ready),
    economic_anchor: candidate.economic_anchor || '',
    sentiment_pulse: candidate.sentiment_pulse || '',
    source_symbol: candidate.symbol || null,
    source_exchange_hint: candidate.exchange_hint || null,
    resolution
  }));
}

function persistWatchList({
  fineTuneData,
  outputDir = DEFAULT_OUTPUT_DIR,
  filenameBase = 'resolved-watch-list',
  format = 'json',
  emitSql = false
}) {
  if (!fineTuneData || !Array.isArray(fineTuneData.final_watch_list)) {
    throw new Error('Fine-tuning phase did not return a final_watch_list array.');
  }

  const resolvedEntries = resolveWatchListCandidates(fineTuneData.final_watch_list);
  const normalizedEntries = normalizeEntries(resolvedEntries);
  const generatedAt = new Date().toISOString();
  const absoluteDir = path.resolve(outputDir || DEFAULT_OUTPUT_DIR);
  ensureDirectory(absoluteDir);

  const safeBase = filenameBase && filenameBase.trim().length ? filenameBase.trim() : 'resolved-watch-list';
  const timestamp = generatedAt.replace(/[:.]/g, '-');
  const baseName = `${safeBase}-${timestamp}`;
  const normalizedFormat = format === 'csv' ? 'csv' : 'json';
  const targetPath = path.join(absoluteDir, `${baseName}.${normalizedFormat}`);

  const payload = normalizedFormat === 'csv'
    ? toCsv(normalizedEntries)
    : JSON.stringify({
        generated_at: generatedAt,
        entry_count: normalizedEntries.length,
        entries: normalizedEntries
      }, null, 2);

  fs.writeFileSync(targetPath, payload, 'utf-8');

  let sqlPath;
  if (emitSql) {
    sqlPath = path.join(absoluteDir, `${baseName}.sql`);
    fs.writeFileSync(sqlPath, buildSqlScript(normalizedEntries), 'utf-8');
  }

  return {
    filePath: targetPath,
    sqlPath,
    entryCount: normalizedEntries.length,
    entries: normalizedEntries
  };
}

module.exports = {
  persistWatchList,
  normalizeEntries,
  buildSqlScript,
  toCsv
};
